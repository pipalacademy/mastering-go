* Session 3: Functions and methods

* Functions are first class in Go

Functions can be assigned to variables, passed as arguments to other functions and returned from other functions.

    func square(n int) int {
        return n*n
    }
    f = square

    fmt.Println(f(4) == square(4)) //true


- Write a function `adder` so that
    add2 := adder(2)
    add100 := adder(100)
    fmt.Println(add2(1), add100(1))
would print 3, 101 respectively.

:* Solution
:.code functions-methods/func_as_var.go


- Write a function `mapper` returns a new slice containing the results of applying the function `f` to each string in the original slice.
    fmt.Println(mapper(strings.ToUpper, []string{"one", "two", "three"})
    ["ONE", "TWO", "THREE"]

: .code functions-methods/func_as_param.go

- Write a function `filter` that returns a new slice containing all strings in the slice that satisfy the predicate `f`.
    fmt.Println(mapper(strings.HasPrefix("o"), []string{"one", "two", "three"})
    ["one"]

- Write a function `all` that returns `true` if all of the strings in the slice satisfy the predicate `f`.
    fmt.Println(all(strings.HasSuffix("o"), []string{"one", "two", "three"})
    false

* Handling errors

Proper error handling is a must for any robust program.
It should also facilitate to find out the cause of the bug quickly.

* Error handling - example

    doc, err := html.Parse(resp.Body)
    defer resp.Body.Close()
    if err != nil {
        return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
    }

- Library functions should usually propagate errors to the caller.
- After checking an error, failure is usually dealt with before success.
- Use `fmt.Errorf` to add more information to the error

* Deferred function calls

A defer statement defers the execution of a function until the surrounding function returns.

- The deferred call's arguments are evaluated immediately.
- It's very effective way to release resources regardless of which path a function takes to return.
- Canonical examples include closing files, db connections and unlocking a mutex.
- When a function returns, its deferred calls are executed in last-in-first-out order.

* example

    func readContents(filename string) (string, error) {
        f, err := os.Open(filename)
        if err != nil {
            return "", err
        }
        defer f.Close()
        // read content from f
        ...
    }

* What would be output of the following

    func main(){
        defer fmt.Println("hello")
        fmt.Println("world")
    }

* Panic and recover

- `panic` is used to terminate the program when the program cannot continue it's execution.
- When a function `f` encounters `panic`, its execution is stopped, any deferred functions are executed and then the control returns to its caller. To the caller, F then behaves like a call to panic and process continues.
- `recover` is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions.

.play -numbers functions-methods/panic_recover.go

* What would be output of
.play -numbers functions-methods/panic_recover_more.go

* Variadic functions

A variadic function is one that can be called with varying numbers of arguments.

`fmt.Println` is a good example of a one.

.play -numbers functions-methods/variadic_sum.go

- Write a function `avg` which takes variable number of float32s and returns their average.
- Write a function `strjoin` that takes a separator as first argument followed by variable number of strings to join with that separator.

* Methods

A method is simply a function with a special `receiver` argument.

.play -numbers functions-methods/methods_basic.go

:.play -numbers functions-methods/methods_strings.go

